<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>Patrick's Blog</title>
		<link>/</link>
		<description />
		<copyright>Copyright © 2024</copyright>
		<managingEditor>Patrick Magee</managingEditor>
		<pubDate>Tue, 04 Jun 2024 18:49:51 GMT</pubDate>
		<lastBuildDate>Tue, 04 Jun 2024 18:49:51 GMT</lastBuildDate>
		<item>
			<title>Portable CI/CD with Dagger</title>
			<link>/posts/2024-06-04-portable-cicd-with-dagger</link>
			<description>&lt;p&gt;Heroes-Decode stands as a powerful .NET CLI Tool meticulously crafted to parse .StormReplay files. Developed and maintained by HeroestoolChest, spearheaded by Kevin Oliva, this tool offers an indispensable utility for processing .StormReplay files.&lt;/p&gt;</description>
			<author>Patrick Magee</author>
			<guid isPermaLink="false">/posts/2024-06-04-portable-cicd-with-dagger</guid>
			<pubDate>Tue, 04 Jun 2024 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="dagger-cicd-a.net-cli-tool-use-case"&gt;Dagger CI/CD: A .NET CLI tool use-case&lt;/h1&gt;
&lt;h2 id="part-1-understanding-heroes-decode"&gt;Part 1: Understanding Heroes-Decode&lt;/h2&gt;
&lt;p&gt;Heroes-Decode stands as a powerful .NET CLI Tool meticulously crafted to parse .StormReplay files. Developed and maintained by HeroestoolChest, spearheaded by Kevin Oliva, this tool offers an indispensable utility for processing .StormReplay files.&lt;/p&gt;
&lt;p&gt;Explore Heroes-Decode on GitHub: &lt;a href="https://github.com/HeroesToolChest/HeroesDecode"&gt;HeroesDecode&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="part-2-using-heroes-decode-in-a-portable-manner"&gt;Part 2: Using Heroes-Decode in a Portable Manner&lt;/h2&gt;
&lt;p&gt;In the pursuit of flexibility and portability, it's essential to liberate our workflows from hard dependencies on .NET.&lt;/p&gt;
&lt;p&gt;Here's what that entails:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;No .NET on Local Machine:&lt;/strong&gt; Striving to maintain a lean setup devoid of any .NET installations.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No .NET Requirement on CICD Runners:&lt;/strong&gt; Ensuring that CICD pipelines remain agnostic to .NET dependencies.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Embracing Portability:&lt;/strong&gt; Fostering an environment where the tool can seamlessly operate in a portable manner.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A portable container:&lt;/strong&gt; Unfortunately, Heroes-Decode lacks an official Docker image.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="part-3-evaluating-available-options"&gt;Part 3: Evaluating Available Options&lt;/h2&gt;
&lt;p&gt;Given the circumstances, various paths present themselves:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Request Docker Image Support:&lt;/strong&gt; Advocating for the creation of an official Docker image.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Self-Sufficiency:&lt;/strong&gt; Leveraging personal expertise to create and utilize a custom Docker image.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Forking and Cloning the Repository:&lt;/strong&gt; Resorting to a DIY approach by forking the repository, constructing a Docker image, and publishing it to Docker Hub.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Containerization:&lt;/strong&gt; Exploring alternative methods to containerize the application &lt;strong&gt;&lt;em&gt;without relying on a Dockerfile&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="part-4-introducing-dagger-cicd"&gt;Part 4: Introducing Dagger CI/CD&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Avoiding Dockerfiles:&lt;/strong&gt; Dagger CI/CD eliminates the need for Dockerfiles, offering a seamless containerization experience.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Creating an Independent Pipeline:&lt;/strong&gt; Run it on any CI/CD platform, be it GitHub Actions, GitLab CI, locally, or any other CI/CD platform.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Leveraging built-in Dagger features:&lt;/strong&gt; Utilizing Dagger's built-in functions to streamline the process of containerizing Heroes-Decode.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Client/Host and Engine communciation:&lt;/strong&gt; Dagger's client/host communication ensures that the pipeline remains efficient and effective.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The Heroes-Decode dagger module, published on the &lt;a href="https://daggerverse.dev/mod/github.com/pjmagee/dagger-heroes-decode&amp;#64;c8b57e0edd4176393468e1dbcf5871ca6bc84b04"&gt;Daggerverse&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With Dagger CI/CD, the process of containerizing Heroes-Decode becomes a breeze, offering a seamless and efficient experience.&lt;/p&gt;
&lt;h2 id="part-5-dagger-breakdown"&gt;Part 5: Dagger breakdown&lt;/h2&gt;
&lt;p&gt;What is it composed of?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dagger CLI:&lt;/strong&gt; A CLI tool that communicates with the Dagger Engine (a containerized service that runs on Containerd/Docker).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dagger Engine:&lt;/strong&gt; A containerized service that executes the Dagger CLI commands.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dagger Modules:&lt;/strong&gt; Reusable modules that encapsulate the logic. These modules can be published on the Daggerverse.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The Dagger API:&lt;/strong&gt; GraphQL API that allows developers to interact with the Dagger Engine.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dagger SDK:&lt;/strong&gt; A language SDK used to communicate to the Dagger Engine via the GraphQL API, which allows developers to create unique, portable CI/CD Pipelines in a supported language (Go, Python, TypesScript).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Daggerverse:&lt;/strong&gt; A repository of Dagger modules that can be utilized to streamline the CI/CD process.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="part-6-breaking-down-the-heroes-decode-dagger-module"&gt;Part 6: Breaking down the Heroes-Decode Dagger Module&lt;/h2&gt;
&lt;p&gt;This code is a Dagger module for the Heroes Decode tool by HeroesToolChest, which decodes Heroes of the Storm replay files. It's written in Go and uses the Dagger SDK to define a containerized environment for running the Heroes Decode tool. Here's a breakdown of the code:
Package and Imports: The code starts by defining the package name and importing necessary packages. The context package is a standard Go package for managing context, while the dagger package is specific to the Dagger SDK.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-go"&gt;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;dagger/dagger-heroes-decode/internal/dagger&amp;quot;
	&amp;quot;fmt&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DaggerHeroesDecode Struct: This struct is the main component of the Dagger module. It doesn't have any fields, as its purpose is to provide methods for running the Heroes Decode tool.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-go"&gt;type DaggerHeroesDecode struct {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Decode Method: This method is where the main logic of the module resides. It takes a context, a file, and an array of additional arguments. It returns a Container object and an error.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-go"&gt;func (m *DaggerHeroesDecode) Decode(
	ctx context.Context,
	// +optional
	// The replay file to decode
	file *dagger.File,
	// +optional
	// Additional arguments to pass to the decoder
	args []string,

) (*Container, error) {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Repository and Directory Setup: The method starts by defining the Git repository of the Heroes Decode tool and the directory where the tool's code resides. It also specifies the version of the tool to use.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-go"&gt;repo := dag.Git(&amp;quot;https://github.com/HeroesToolChest/HeroesDecode.git&amp;quot;)
dir := repo.Tag(&amp;quot;v1.4.0&amp;quot;).Tree()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Container Setup: Two containers are defined: one for building the Heroes Decode tool and one for running it. The build container uses the .NET SDK, while the app container uses the .NET runtime. The build container compiles the Heroes Decode tool, and the app container runs the compiled tool.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-go"&gt;build := dag.Container().
		From(&amp;quot;mcr.microsoft.com/dotnet/sdk:8.0&amp;quot;).
		WithWorkdir(&amp;quot;/app&amp;quot;).
		WithDirectory(&amp;quot;/app&amp;quot;, dir.Directory(&amp;quot;HeroesDecode&amp;quot;)).
		WithExec([]string{&amp;quot;dotnet&amp;quot;, &amp;quot;publish&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;Release&amp;quot;})

app := dag.Container().
		From(&amp;quot;mcr.microsoft.com/dotnet/runtime:8.0&amp;quot;).
		WithWorkdir(&amp;quot;/app&amp;quot;).
		WithDirectory(&amp;quot;/app&amp;quot;, build.Directory(&amp;quot;/app/bin/Release/net8.0/publish&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Command Setup: The command to run the Heroes Decode tool is defined. If a file is provided, it's added to the command. If additional arguments are provided, they're also added to the command.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-go"&gt;cmd := []string{&amp;quot;./HeroesDecode&amp;quot;}

if file != nil {
	replay := []string{&amp;quot;--replay-path&amp;quot;, replayPath}
	app.WithFile(replayPath, file)
	cmd = append(cmd, replay...)
}

if args != nil {
	cmd = append(cmd, args...)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Container Execution: Finally, the app container is set to execute the command and sync with the context.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-go"&gt;return app.
		WithExec(cmd).
		Sync(ctx)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="part-7-using-the-dagger-module"&gt;Part 7: Using the Dagger module&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dagger -m github.com/pjmagee/dagger-heroes-decode&amp;#64;v1.0.0 call decode -h
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;USAGE
  dagger call decode [arguments] &amp;lt;function&amp;gt;

FUNCTIONS
  as-service                    Turn the container into a Service.
  as-tarball                    Returns a File representing the container serialized to a tarball.
  build                         Initializes this container from a Dockerfile build.
  default-args                  Retrieves default arguments for future commands.
  directory                     Retrieves a directory at the given path.
  entrypoint                    Retrieves entrypoint to be prepended to the arguments of all commands.
  env-variable                  Retrieves the value of the specified environment variable.
  env-variables                 Retrieves the list of environment variables passed to commands.
  experimental-with-all-gp-us   EXPERIMENTAL API! Subject to change/removal at any time.
  experimental-with-gpu         EXPERIMENTAL API! Subject to change/removal at any time.
  export                        Writes the container as an OCI tarball to the destination file path on the host.
  exposed-ports                 Retrieves the list of exposed ports.
  file                          Retrieves a file at the given path.
  from                          Initializes this container from a pulled base image.
  image-ref                     The unique image reference which can only be retrieved immediately after the
                                'Container.From' call.
  import                        Reads the container from an OCI tarball.
  label                         Retrieves the value of the specified label.
  labels                        Retrieves the list of labels passed to container.
  mounts                        Retrieves the list of paths where a directory is mounted.
  pipeline                      Creates a named sub-pipeline.
  platform                      The platform this container executes and publishes as.
  publish                       Publishes this container as a new image to the specified address.
  rootfs                        Retrieves this container's root filesystem. Mounts are not included.
  stderr                        The error stream of the last executed command.
  stdout                        The output stream of the last executed command.
  sync                          Forces evaluation of the pipeline in the engine.
  terminal                      Return an interactive terminal for this container using its configured default terminal
                                command if not overridden by args (or sh as a fallback default).
  user                          Retrieves the user to be set for all commands.
  with-default-args             Configures default arguments for future commands.
  with-default-terminal-cmd     Set the default command to invoke for the container's terminal API.
  with-directory                Retrieves this container plus a directory written at the given path.
  with-entrypoint               Retrieves this container but with a different command entrypoint.
  with-env-variable             Retrieves this container plus the given environment variable.
  with-exec                     Retrieves this container after executing the specified command inside it.
  with-exposed-port             Expose a network port.
  with-file                     Retrieves this container plus the contents of the given file copied to the given path.
  with-files                    Retrieves this container plus the contents of the given files copied to the given path.
  with-focus                    Indicate that subsequent operations should be featured more prominently in the UI.
  with-label                    Retrieves this container plus the given label.
  with-mounted-cache            Retrieves this container plus a cache volume mounted at the given path.
  with-mounted-directory        Retrieves this container plus a directory mounted at the given path.
  with-mounted-file             Retrieves this container plus a file mounted at the given path.
  with-mounted-secret           Retrieves this container plus a secret mounted into a file at the given path.
  with-mounted-temp             Retrieves this container plus a temporary directory mounted at the given path. Any
                                writes will be ephemeral to a single withExec call; they will not be persisted to
                                subsequent withExecs.
  with-new-file                 Retrieves this container plus a new file written at the given path.
  with-registry-auth            Retrieves this container with a registry authentication for a given address.
  with-rootfs                   Retrieves the container with the given directory mounted to /.
  with-secret-variable          Retrieves this container plus an env variable containing the given secret.
  with-service-binding          Establish a runtime dependency on a service.
  with-user                     Retrieves this container with a different command user.
  with-workdir                  Retrieves this container with a different working directory.
  without-default-args          Retrieves this container with unset default arguments for future commands.
  without-directory             Retrieves this container with the directory at the given path removed.
  without-entrypoint            Retrieves this container with an unset command entrypoint.
  without-env-variable          Retrieves this container minus the given environment variable.
  without-exposed-port          Unexpose a previously exposed port.
  without-file                  Retrieves this container with the file at the given path removed.
  without-focus                 Indicate that subsequent operations should not be featured more prominently in the UI.
  without-label                 Retrieves this container minus the given environment label.
  without-mount                 Retrieves this container after unmounting everything at the given path.
  without-registry-auth         Retrieves this container without the registry authentication of a given address.
  without-secret-variable       Retrieves this container minus the given environment variable containing the secret.
  without-unix-socket           Retrieves this container with a previously added Unix socket removed.
  without-user                  Retrieves this container with an unset command user.
  without-workdir               Retrieves this container with an unset working directory.
  workdir                       Retrieves the working directory for all commands.

ARGUMENTS
      --args strings   Additional arguments to pass to the decoder
      --file File      The replay file to decode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example usage&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;C:\Projects\pjmagee\dagger-heroes-decode [main ≡ +0 ~1 -0 !]&amp;gt; dagger call decode --file='C:\Users\patri\2024-06-04 17.49.26 Hanamura Temple.StormReplay' stdout
Success
 File Name: 2024-06-04T18_41_07.762628899Z.StormReplay
 Game Mode: QuickMatch
       Map: Hanamura Temple [Hanamura]
   Version: 2.55.5.92264
    Region: EU
 Game Time: 00:16:48
     Lobby: Standard
Ready Mode: FCFS
First Drft: CoinToss
  Ban Mode: NotUsingBans
   Privacy: Normal
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Team Blue (Winner)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[-]   Player: Heartyfellow#
Player Level: 1383
 Player Toon: 2-Hero-1-7405397
   Hero Name: Xul [HeroNecromancer]
  Hero Level: 25
       Award: MostRoots

[-]   Player: Jamal#2101
Player Level: 1284
 Player Toon: 2-Hero-1-1870498
   Hero Name: Samuro [HeroSamuro]
  Hero Level: 6
       Award: MostMercCampsCaptured

[-]   Player: Winer#
Player Level: 436
 Player Toon: 2-Hero-1-7066747
   Hero Name: Sgt. Hammer [HeroSgtHammer]
  Hero Level: 75
       Award: MostHeroDamageDone

[-]   Player: pikkis23#
Player Level: 1260
 Player Toon: 2-Hero-1-13136396
   Hero Name: Junkrat [HeroJunkrat]
  Hero Level: 75
       Award: MVP

[-]   Player: Dota2Refugee#
Player Level: 266
 Player Toon: 2-Hero-1-13944224
   Hero Name: Malfurion [HeroMalfurion]
  Hero Level: 25

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Team Red
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[5]   Player: DukeFleed#
Player Level: 779
 Player Toon: 2-Hero-1-1949829
   Hero Name: Alarak [HeroAlarak]
  Hero Level: 100

[5]   Player: skitzo#
Player Level: 200
 Player Toon: 2-Hero-1-13583013
   Hero Name: Rehgar [HeroRehgar]
  Hero Level: 20

[6]   Player: Quant#
Player Level: 3608
 Player Toon: 2-Hero-1-2214388
   Hero Name: Abathur [HeroAbathur]
  Hero Level: 100
       Award: MostSiegeDamageDone

[6]   Player: Caipa2mic#
Player Level: 1299
 Player Toon: 2-Hero-1-12625530
   Hero Name: Li-Ming [HeroWizard]
  Hero Level: 100

[6]   Player: Qlark#
Player Level: 707
 Player Toon: 2-Hero-1-13849640
   Hero Name: Genji [HeroGenji]
  Hero Level: 20

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Observers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(NONE)

C:\Projects\pjmagee\dagger-heroes-decode [main ≡ +0 ~1 -0 !]&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="part-8-conclusion"&gt;Part 8: Conclusion&lt;/h2&gt;
&lt;p&gt;Dagger CI/CD offers a revolutionary approach to containerization, eliminating the need for Dockerfiles and providing a seamless experience. With the Heroes-Decode Dagger module, it's callable by anyone with the Dagger CLI, offering a portable and efficient solution for those who do not wish to install .NET and want to run the Heroes-Decode tool in a containerized environment.&lt;/p&gt;
&lt;p&gt;The Heroes-Decode Dagger module is available on the &lt;a href="https://daggerverse.dev/mod/github.com/pjmagee/dagger-heroes-decode&amp;#64;c8b57e0edd4176393468e1dbcf5871ca6bc84b04"&gt;Daggerverse&lt;/a&gt;, enabling users to leverage the power of Dagger CI/CD for their containerization needs.&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>How to hi-jack CEF applications</title>
			<link>/posts/2023-01-02-how-to-hijack-production-cef-applications</link>
			<description>&lt;p&gt;It's important to ensure that you disable debugging functionality before releasing to production. Password protecting your CEF application exe can be bypassed by users who know which arguments they should pass to the exe, which can enable users to bypass the security you put in place.&lt;/p&gt;</description>
			<author>Patrick Magee</author>
			<guid isPermaLink="false">/posts/2023-01-02-how-to-hijack-production-cef-applications</guid>
			<pubDate>Mon, 02 Jan 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;It's important to ensure that you disable debugging functionality before releasing to production. Password protecting your CEF application exe can be bypassed by users who know which arguments they should pass to the exe, which can enable users to bypass the security you put in place.&lt;/p&gt;
&lt;p&gt;Take the example below where the self contained isolated non Steam version of the Launcher for SWTOR does not protect against remote debugging, enabling the ability to extract full source code of the Launcher, reverse engineer the native interop to the C++ dll and also being able to automate the usage of the desktop application with a WebDriver.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;
async Task Main()
{	
	// use 1Password CLI to extract item you need for logging in

    var opCLI = &amp;#64;&amp;quot;C:\Users\patri\OneDrive\tools\op.exe&amp;quot;;
    var args = &amp;quot;item get SWTOR --format json&amp;quot;;
    var driverExeDir = &amp;#64;&amp;quot;C:\Users\patri\Downloads\chromedriver_win32&amp;quot;;
    var cefClient = &amp;#64;&amp;quot;G:\Star Wars - The Old Republic\launcher.exe&amp;quot;;

	using (var op = Process.Start(new ProcessStartInfo { FileName = opCLI, RedirectStandardOutput = true, Arguments = args }))
	{
		using(var document = JsonDocument.Parse(await op.StandardOutput.ReadToEndAsync()))
		{
			var items = document.RootElement
                .GetProperty(&amp;quot;fields&amp;quot;)
                .EnumerateArray()
                .Where(x =&amp;gt; x.GetProperty(&amp;quot;id&amp;quot;).ValueEquals(&amp;quot;username&amp;quot;) || 
                            x.GetProperty(&amp;quot;id&amp;quot;).ValueEquals(&amp;quot;password&amp;quot;) || 
                            x.GetProperty(&amp;quot;type&amp;quot;).ValueEquals(&amp;quot;OTP&amp;quot;))
                .ToArray();

			var details = new
			{
				username = items[0].GetProperty(&amp;quot;value&amp;quot;).GetString(),
				password = items[1].GetProperty(&amp;quot;value&amp;quot;).GetString(),
				otp = items[2].GetProperty(&amp;quot;totp&amp;quot;).GetString(),
			};

			// Chrome/75.0.3770.100
			// Download the Driver for the CEF client exe and configure additional arguments			
			var options = new ChromeOptions() { LeaveBrowserRunning = true, BinaryLocation = cefClient };
			options.AddArgument(&amp;quot;--debug&amp;quot;);
			options.AddArgument(&amp;quot;--remote-debugging-port=9222&amp;quot;);
			
			using (IWebDriver driver = new ChromeDriver(driverExeDir, options))
			{
				// Use Chrome/Edge and inspect to find the right elements you need to automate and then apply this to your code				
				driver.FindElement(By.XPath(&amp;quot;//*[&amp;#64;id=\&amp;quot;usernameInput\&amp;quot;]&amp;quot;)).Clear();				
				driver.FindElement(By.XPath(&amp;quot;//*[&amp;#64;id=\&amp;quot;usernameInput\&amp;quot;]&amp;quot;)).SendKeys(details.username);
				
				driver.FindElement(By.XPath(&amp;quot;//*[&amp;#64;id=\&amp;quot;passwordInput\&amp;quot;]&amp;quot;)).SendKeys(details.password);
				driver.FindElement(By.XPath(&amp;quot;//*[&amp;#64;name=\&amp;quot;securitykey\&amp;quot;]&amp;quot;)).SendKeys(details.otp);
				
				driver.FindElement(By.Id(&amp;quot;nextButton&amp;quot;)).Click();	
				
				await Task.Delay(1000);				
				driver.FindElement(By.Id(&amp;quot;closeAlertsBtn&amp;quot;)).Click();				
				await Task.Delay(2000);				
				driver.FindElement(By.ClassName(&amp;quot;hitbox&amp;quot;)).Click();
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>SWTOR and Login Automation</title>
			<link>/posts/2022-12-22-swtor-login-automation</link>
			<description>&lt;p&gt;Power Automate should be installed already if you are on Windows 11. I created a brand new flow and named it 'SWTOR Launch'.&lt;/p&gt;</description>
			<author>Patrick Magee</author>
			<guid isPermaLink="false">/posts/2022-12-22-swtor-login-automation</guid>
			<pubDate>Thu, 22 Dec 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;Power Automate should be installed already if you are on Windows 11. I created a brand new flow and named it 'SWTOR Launch'.&lt;/p&gt;
&lt;p&gt;You will need to install the 1Password CLI too and ensure it's added to your &lt;code&gt;PATH&lt;/code&gt; like any other tool.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/i397HPZ.png" alt="1Password CLI setting"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/xrPllgz.png" alt="Power Automate"&gt;&lt;/p&gt;
&lt;p&gt;There are almost endless possibilies to automate tasks from Power automate ranging from remote to local. Lets take a look at how I have automated the login process for SWTOR.&lt;/p&gt;
&lt;p&gt;The next screenshot shows all the individual actions I have inserted as part of my new flow. Each step is using a specific feature which you can click and drag onto the flow which you can then further customise each step to read from custom variables etc.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/J7Kb9QM.png" alt="Flow Steps"&gt;&lt;/p&gt;
&lt;p&gt;The first step is to ensure the Launcher is actually running, so that we can insert the credentials into the launcher. The next step is to create a custom script step and use the 1Password CLI tool (added to my PATH) and to use the special one password item API to extract the credentials from my Password manager (This step actually activates Windows Hello, where I can tap my Ubikey to authenticate and allow 1Password to continue).&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/KPaEgUJ.png" alt="1Password"&gt;&lt;/p&gt;
&lt;p&gt;This command is essentually going to extract the following which is stored in my 1Password like so.....&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/8XnU7FT.png" alt="1Password output"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/3RJeY9k.png" alt="1Password item"&gt;&lt;/p&gt;
&lt;p&gt;We want 1Password to output this in a format which we can then consume easily in Power Automate, which is &lt;code&gt;JSON&lt;/code&gt; so we use the &lt;code&gt;--format json&lt;/code&gt;. This is then inserted into a `%PowershellOutput% variable. Variables can be freely renamed, I just left the default name.&lt;/p&gt;
&lt;p&gt;Once we have this, we want to then navigate and extract some of the variables for debugging and ease of use in the following step, which is to convert JSON to a &lt;code&gt;custom object&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/DrC76ud.png" alt="Convert to custom object"&gt;&lt;/p&gt;
&lt;p&gt;Once the step runs, you'll notice that the variables are visible as they become populated on the right hand side of the flow window.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/5jgP9uN.png" alt="Variables"&gt;&lt;/p&gt;
&lt;p&gt;I then fill in the following additional variables based on the fields that will need to entered within the Launcher. Using the &lt;code&gt;custom object&lt;/code&gt; accessors I populate the variables so that they can be used in the UI automation steps.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/Y8wIngk.png" alt="Secrets"&gt;&lt;/p&gt;
&lt;p&gt;Next is to ensure that the UI Elements are configured in Power Automate. You can add UI elements by selecting Windows and configuring how it should scan a UI for fields.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/vn8wqww.png" alt="UI Element 1"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/UcSyi7L.png" alt="UI Element 2"&gt;&lt;/p&gt;
&lt;p&gt;You will need to this process for each individual element that needs to have text entered or clicked on.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/sHVogED.png" alt="UI Element 3"&gt;&lt;/p&gt;
&lt;p&gt;Once the UI elements are in, we can then add steps to &lt;code&gt;reference&lt;/code&gt; these UI elements and populate them.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/Bth1UFc.png" alt="UI Element 4"&gt;&lt;/p&gt;
&lt;p&gt;Here's a 30s demo of Power Automate running the flow&lt;/p&gt;
&lt;p&gt;&lt;img src="/img/swtor/automate.gif" alt="UI Element 5"&gt;&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>1Password and SSH</title>
			<link>/posts/2022-04-18-1password-and-ssh</link>
			<description>&lt;p&gt;I've been using a Password manager for years now, however one thing which always annnoyed me was the lack of SSH support and having your Private key stored in the .ssh folder on your machine. Or you would have to manually generate your SSH key using Putty. Then you would upload your public key and make sure you never lost your private key since it was always stored in the .ssh folder unless you backed it up securely and then would put it back on a fresh install.&lt;/p&gt;</description>
			<author>Patrick Magee</author>
			<guid isPermaLink="false">/posts/2022-04-18-1password-and-ssh</guid>
			<pubDate>Mon, 18 Apr 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;I've been using a Password manager for years now, however one thing which always annnoyed me was the lack of SSH support and having your Private key stored in the .ssh folder on your machine. Or you would have to manually generate your SSH key using Putty. Then you would upload your public key and make sure you never lost your private key since it was always stored in the .ssh folder unless you backed it up securely and then would put it back on a fresh install.&lt;/p&gt;
&lt;p&gt;1Password has a feature which allows it to act as an SSH Agent meaning you no longer need to store your secrets on disk in the .ssh folder but can instead store your SSH data in 1Password.&lt;/p&gt;
&lt;p&gt;1Password allows you to store all sorts of sensitive information. You can see in the screenshot below that SSH is an option.&lt;/p&gt;
&lt;p&gt;&lt;img src="/img/1password-ssh/1.png" alt="Create Password"&gt;&lt;/p&gt;
&lt;p&gt;Once you select the SSH Option, you can optionally name the SSH Key and even paste in or upload an existing private ssh key.&lt;/p&gt;
&lt;p&gt;&lt;img src="/img/1password-ssh/2.png" alt="Create or Paste"&gt;&lt;/p&gt;
&lt;p&gt;You will need to make sure any existing SSH Agent Service is not running.
This will allow 1Password to take control over the SSH Named Pipe on Windows.
This should be supported by most Git Versioning tools such as Git for Windows.&lt;/p&gt;
&lt;p&gt;&lt;img src="/img/1password-ssh/4.png" alt="Enable the 1Password SSH Agent"&gt;&lt;/p&gt;
&lt;p&gt;Using Windows Hello Feature, you can see it asks for my PIN. There are other approaches such as using your USB YubiKey to also Authenticate and unlock the 1Password Wallet.
Once I'm validated my SSH session will continue and I will be able to use git push or pull commands using the private SSH Key which is linked to the public SSH key that I uploaded to Github.&lt;/p&gt;
&lt;p&gt;&lt;img src="/img/1password-ssh/3.png" alt="Demo Popup"&gt;&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Heroes of the Storm and D3.js</title>
			<link>/posts/2021-08-07-heroes-of-the-storm-d3js</link>
			<description>&lt;p&gt;One of my favourite games is a hero brawler game called Heroes of the Storm. It's a 5 people versus 5 people game.&lt;br&gt;
There are 3 lanes on the map and the goal is to kill their core before they kill your core.&lt;/p&gt;</description>
			<author>Patrick Magee</author>
			<guid isPermaLink="false">/posts/2021-08-07-heroes-of-the-storm-d3js</guid>
			<pubDate>Thu, 08 Jul 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;One of my favourite games is a hero brawler game called Heroes of the Storm. It's a 5 people versus 5 people game.&lt;br /&gt;
There are 3 lanes on the map and the goal is to kill their core before they kill your core.&lt;/p&gt;
&lt;p&gt;The general layout of a map is usually split into 3 lanes. Every 30 seconds you have some minions that travel down the lanes and meet half way and the idea throughout the session is to what ever it costs to win. That could be team fights, gaining xp from minions, destroying enemy buildings, ganking enemies etc. There are many ways to win just as there are many ways to lose.
Heroes are unique units that players can control in the game that bring a unique style to how that team might win or lose. There are over 90 heroes to select from which can become extremely complicated for new players to learn and understand how to counter those heroes of they come up against them.&lt;/p&gt;
&lt;p&gt;Heroes are split into several main categories: Tank, Bruiser, Ranged Assassin, Melee Assassin, Healer &amp;amp; Support. This is only a very high level view of the complexity of this game.&lt;/p&gt;
&lt;p&gt;When you break it down to how a hero's style and unique capabilties can bring something positive to a team, it will also depend on how well the hero performs on a certain map, and if their hero counters enemy heroes or if they also work well with other heroes in their team.&lt;/p&gt;
&lt;p&gt;There is a project on Github called HeroesToolChest by a guy named Kevin who has a tool that exports string data from the Game itself. Using this data, I was able to transform the information that is not always available even in the UI of the game and produce a hierarchical edge graph that can show relationships between different elements of the game.&lt;/p&gt;
&lt;p&gt;Once I was able to extract all the required information to produce the graph, I went online and forked an example of d3.js that I could use as the foundation for displaying the data I wanted to show.&lt;/p&gt;
&lt;p&gt;Selecting one of the edge nodes, such as Complexity, will allow you see all heroes that have been labeled with the same complexity.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/292720/128598800-751da65d-2418-418a-afdc-ff345feb1d56.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;You can also do the reverse by selecting an individual Hero and see all the other things that Hero relates to.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/292720/128598831-88461845-27bb-4e76-b26b-f7501fcdf8dc.png" alt="image" /&gt;&lt;/p&gt;
&lt;script src="https://gist.github.com/pjmagee/a3d58c994f38ca6e4d7bdde7312e29fa.js"&gt;&lt;/script&gt;
&lt;p&gt;&lt;a href="https://observablehq.com/&amp;#64;pjmagee/heroes-of-the-storm-hero-relationships"&gt;Checkout the full relationship graph on Observable HQ&lt;/a&gt;&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Blazor &amp; SVG files - Part 2</title>
			<link>/posts/2020-02-17-blazor-and-svg-files-part-2</link>
			<description>&lt;p&gt;It's been a while since my last blog post about Blazor.  My original blog post was showing how to use Blazer client side only with SVG files, by requesting those images using a http client from the browser and getting the content from the wwwroot.&lt;/p&gt;</description>
			<author>Patrick Magee</author>
			<guid isPermaLink="false">/posts/2020-02-17-blazor-and-svg-files-part-2</guid>
			<pubDate>Mon, 17 Feb 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;It's been a while since my last blog post about Blazor.  My original blog post was showing how to use Blazer client side only with SVG files, by requesting those images using a http client from the browser and getting the content from the wwwroot.&lt;/p&gt;
&lt;p&gt;But what if you are using &lt;code&gt;services.AddServerSideBlazor();&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;My solution was to make use of &lt;code&gt;IWebHostEnvironment&lt;/code&gt;, and inject this into the registered &lt;code&gt;SvgService&lt;/code&gt;. Doing this, you get access to the &lt;code&gt;WebRootFileProvider&lt;/code&gt;, from there you can query other sub folders within the &lt;code&gt;wwwroot&lt;/code&gt;.&lt;/p&gt;
&lt;script src="https://gist.github.com/pjmagee/98b0995581ebbb7ea9d64a21863e0d43.js"&gt;&lt;/script&gt;
&lt;p&gt;Now with the &lt;code&gt;SvgService&lt;/code&gt; defined, which is a collection of svg's for different technology stacks, you can pass this into any &lt;code&gt;Component&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;@inject&lt;/code&gt;, &lt;code&gt;[Inject]&lt;/code&gt; or &lt;code&gt;@inherits OwningComponentBase&lt;/code&gt; you can get an instance of the &lt;code&gt;SvgService&lt;/code&gt;, and use it to render the svg.&lt;/p&gt;
&lt;h3 id="example-markup"&gt;Example markup&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;td class="@item.Kind.GetIconClass() text-center"&amp;gt;@SvgService.GetSvg(item.Kind)&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="example-component-code"&gt;Example component code&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;@code
{
    [Inject]
    SvgService SvgService { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;GetSvg&lt;/code&gt; function has an enum parameter, using the new &lt;code&gt;C# 9 switch syntax&lt;/code&gt; it accesses the raw SVG contents stored in the Dictionary as &lt;code&gt;MarkupString&lt;/code&gt;, which Blazor knows how to render properly on the page.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;public MarkupString GetSvg(EcosystemKind kind) =&amp;gt; kind switch
{
    EcosystemKind.Docker =&amp;gt; svgs["docker"],
    EcosystemKind.Gradle =&amp;gt; svgs["gradle"],
    EcosystemKind.Maven =&amp;gt; svgs["java"],
    EcosystemKind.Npm =&amp;gt; svgs["npm"],
    EcosystemKind.NuGet =&amp;gt; svgs["nuget"],
    EcosystemKind.PyPi =&amp;gt; svgs["python"],
    EcosystemKind.RubyGem =&amp;gt; svgs["ruby"],
    _ =&amp;gt; Empty
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For something this simple with no user/request specific data, this can be registered as a &lt;code&gt;Singleton&lt;/code&gt; instance and shared to all components.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;    private static IServiceCollection RegisterRazorComponentServices(this IServiceCollection services) =&amp;gt; services
            .AddSingleton&amp;lt;SvgService&amp;gt;() // Share this same SVG service across ALL components
            .AddScoped&amp;lt;NavigationService&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="improving-on-this-solution"&gt;Improving on this solution&lt;/h2&gt;
&lt;p&gt;The next step would be figure out if you can make the SVG Service, an easy to use sharable Blazor component itself, something such as &lt;code&gt;&amp;lt;CustomSvg Kind="enum" /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;blockquote class="imgur-embed-pub" lang="en" data-id="mlo3eJH"&gt;&lt;a href="//imgur.com/mlo3eJH"&gt;View post on imgur.com&lt;/a&gt;&lt;/blockquote&gt;&lt;script async="" src="//s.imgur.com/min/embed.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="imgur-embed-pub" lang="en" data-id="lyZoaYN"&gt;&lt;a href="//imgur.com/lyZoaYN"&gt;View post on imgur.com&lt;/a&gt;&lt;/blockquote&gt;&lt;script async="" src="//s.imgur.com/min/embed.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="imgur-embed-pub" lang="en" data-id="9dhvv0e"&gt;&lt;a href="//imgur.com/9dhvv0e"&gt;View post on imgur.com&lt;/a&gt;&lt;/blockquote&gt;&lt;script async="" src="//s.imgur.com/min/embed.js" charset="utf-8"&gt;&lt;/script&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Blazor &amp; SVG files - Part 1</title>
			<link>/posts/2019-03-19-blazor-and-svg-files-part-1</link>
			<description>&lt;p&gt;I've been experimenting with Blazor and using Bootstrap with SVG's. For Angular I remember that the Material design library had a really nice way of being able to pull in SVG files but this doesn't quite yet exist for blazor.&lt;/p&gt;</description>
			<author>Patrick Magee</author>
			<guid isPermaLink="false">/posts/2019-03-19-blazor-and-svg-files-part-1</guid>
			<pubDate>Tue, 19 Mar 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;I've been experimenting with Blazor and using Bootstrap with SVG's. For Angular I remember that the Material design library had a really nice way of being able to pull in SVG files but this doesn't quite yet exist for blazor.&lt;/p&gt;
&lt;p&gt;I was really keen on using some SVG's from &lt;a href="https://simpleicons.org/"&gt;Simple Icons&lt;/a&gt; which contains loads of SVG's based on popular brands.&lt;/p&gt;
&lt;p&gt;Well, you're probably thinking, what do you mean &amp;quot;nice way of pulling in SVG files&amp;quot;. You just use the &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tag and in the &lt;code&gt;src&lt;/code&gt; attribute just throw in the path to the svg file that is served from the server. Well, it's not the easy if you wan't to manipulate or style your SVG, since you cant do that by using the &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tag approach. There are other solutions that use &lt;code&gt;jQuery&lt;/code&gt; to load that file and then replace the &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tag with the actual raw &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt; but it was just so many lines of code and also it didnt seem like a good solution for my problem because I don't really want to use &lt;code&gt;jquery&lt;/code&gt; unless i reeaaallly need to, since i want to write the least amount of js as possible.&lt;/p&gt;
&lt;p&gt;Here is a quick way of directly loading raw SVG files through a Helper which you can &lt;code&gt;&amp;#64;inject&lt;/code&gt; into your blazor pages. This way, you only need to call the files once, load them in as &lt;code&gt;MarkupString&lt;/code&gt; and they will be output as Raw html.&lt;/p&gt;
&lt;script src="https://gist.github.com/pjmagee/b4bc15a8325065f48412a230df453b01.js"&gt;&lt;/script&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Blazor &amp; Pagination</title>
			<link>/posts/2019-03-19-blazor-and-pagination</link>
			<description>&lt;p&gt;The snippets below can be used to create a pagination razor component for a Bootstrap table with a pager.&lt;/p&gt;</description>
			<author>Patrick Magee</author>
			<guid isPermaLink="false">/posts/2019-03-19-blazor-and-pagination</guid>
			<pubDate>Mon, 18 Mar 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;The snippets below can be used to create a pagination razor component for a Bootstrap table with a pager.&lt;/p&gt;
&lt;p&gt;When the pager component recieves a click event, it sends that event back to the parent page component, and calls the &lt;code&gt;PageAsync&lt;/code&gt; function to get the requested page from the server.&lt;/p&gt;
&lt;p&gt;We then call the &lt;code&gt;StateHasChanged()&lt;/code&gt; function to ensure the component is rerendered and sent back to the client.&lt;/p&gt;
&lt;p&gt;The last snippet shows the page component and the pager component is placed under the actual table where you would render the columns and rows for the Items.&lt;/p&gt;
&lt;p&gt;The bootstrap markup is being rendered by using &lt;a href="https://github.com/chanan/BlazorStrap"&gt;BlazorStrap&lt;/a&gt;, a NuGet package which provides razor components that generate bootstrap 4 markup.&lt;/p&gt;
&lt;script src="https://gist.github.com/pjmagee/69b10e448baa276486aa1641bd395be8.js"&gt;&lt;/script&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>